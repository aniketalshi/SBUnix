void switch_to_user_mode(task_struct *ts_obj) {
    set_kernel_stack(ts_obj->kernel_stack[KERNEL_STACK_SIZE-1]);
    kprintf("inside switch to user mode: %lx\n", ts_obj->rip);
    uint64_t pml4 = ts_obj->pml4 & ~0xFFF;
    kprintf("pml4 is %lx\n",pml4);

    __asm__ __volatile__ (
        "cli;"
        "movq %0, %%cr3;"
        "mov $0x23, %%ax;"
        "mov %%ax, %%ds;"
        "mov %%ax, %%es;"
        "mov %%ax, %%fs;"
        "mov %%ax, %%gs;"

        "movq %1, %%rax;"
        "pushq $0x23;"
        "pushq %%rax;"
        "pushfq;"
        "popq %%rax;"
        "orq $0x200, %%rax;"
        "pushq %%rax;"
        "pushq $0x1B;"
        "pushq %2;"
        "iretq;"
        ::"r"(pml4), "r"(ts_obj->rsp), "r"(ts_obj->rip)
    );
}
//
//void nswitch_to(struct task_struct *next, struct task_struct *prev) {
//printf("switch_to\n");
//    set_tss_rsp0(next->kernel_stack);
//    __asm__ __volatile__ (
//        "cli;"
//        "movq %%rsp, (%1);"     // save RSP
//        "movq $1f, %0;"         // save RIP
//        "movq %2, %%rsp;"   	// load next->stack var in rsp
//        "movq %4, %%cr3;"	// load next->pml4 into cr3
//        "pushq %3;"             // restore RIP so as to continue execution in next task
//        "retq;"                 // Switch to new task
//        "1:\t"
//        :"=g"(prev->rip)
//        :"r"(&(prev->kernel_stack)), "r"(next->kernel_stack), "r"(next->rip), "r"(next->pml4)
//    );
//    kprintf("Hello is resuming after idle..\n");
//}
//
//void nschedule() {
//    kprintf("inside schedule\n");
//    task_struct *prev = current_task; 
//    current_task = current_task->next;
//    if(current_task != prev){
//        switch_to(current_task,prev);}
//    kprintf("returing from schedule\n");
//}
//
